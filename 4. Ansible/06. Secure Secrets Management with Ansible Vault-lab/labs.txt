Lab 6: Secure Secrets Management with Ansible Vault
Lab Objectives
By the end of this lab, you will be able to:

Understand the importance of securing sensitive data in automation workflows
Create and encrypt sensitive data using ansible-vault commands
Decrypt and use encrypted vault data in Ansible playbooks
Implement best practices for managing secrets in Ansible environments
Work with different vault encryption methods and password management techniques
Prerequisites
Before starting this lab, you should have:

Basic understanding of Linux command line operations
Familiarity with text editors (nano, vim, or similar)
Basic knowledge of YAML syntax
Understanding of Ansible fundamentals (playbooks, tasks, variables)
Completed previous Ansible labs or equivalent experience
Lab Environment
Al Nafi Cloud Machine Setup: This lab runs entirely on a single Linux machine provided by Al Nafi. Simply click Start Lab to access your dedicated Linux environment. The machine comes as bare metal with no pre-installed tools, so we will install all required software during the lab.

Important Note: All tasks in this lab will be performed on the same Linux machine. No additional machines, virtual environments, or remote hosts are required.

Task 1: Environment Setup and Ansible Installation
Subtask 1.1: Update System and Install Dependencies
First, let's prepare our system and install the necessary tools.

# Update the package manager
sudo apt update && sudo apt upgrade -y

# Install Python3 and pip if not already installed
sudo apt install python3 python3-pip python3-venv -y

# Install additional dependencies
sudo apt install curl wget git -y
Subtask 1.2: Install Ansible
# Install Ansible using pip
pip3 install ansible

# Add pip installation path to PATH if needed
echo 'export PATH=$PATH:~/.local/bin' >> ~/.bashrc
source ~/.bashrc

# Verify Ansible installation
ansible --version
ansible-vault --version
Subtask 1.3: Create Lab Directory Structure
# Create main lab directory
mkdir -p ~/ansible-vault-lab
cd ~/ansible-vault-lab

# Create subdirectories for organization
mkdir -p {playbooks,inventory,group_vars,host_vars,vault_files}

# Create a basic inventory file
cat > inventory/hosts << 'EOF'
[local]
localhost ansible_connection=local
EOF
Task 2: Create and Encrypt Sensitive Data using ansible-vault
Subtask 2.1: Understanding Ansible Vault Basics
Ansible Vault is a feature that allows you to encrypt sensitive data such as passwords, API keys, and certificates. Let's start by understanding the basic vault commands.

# Display ansible-vault help
ansible-vault --help
Subtask 2.2: Create Your First Encrypted File
Let's create a vault file containing database credentials.

# Create an encrypted vault file
ansible-vault create vault_files/database_secrets.yml
When prompted, enter a vault password (remember this password - you'll need it later). For this lab, use: MySecretPassword123

In the editor that opens, add the following content:

# Database connection secrets
db_username: admin_user
db_password: super_secret_password_123
db_host: localhost
db_port: 5432
db_name: production_db

# API Keys
api_key: abc123def456ghi789
secret_token: xyz987uvw654rst321

# SSL Certificate paths
ssl_cert_path: /etc/ssl/certs/myapp.crt
ssl_key_path: /etc/ssl/private/myapp.key
Save and exit the editor.

Subtask 2.3: View Encrypted File Content
# Try to view the encrypted file directly
cat vault_files/database_secrets.yml

# View the encrypted file using ansible-vault
ansible-vault view vault_files/database_secrets.yml
Enter your vault password when prompted.

Subtask 2.4: Create Additional Vault Files
Let's create more vault files for different environments.

# Create staging environment secrets
ansible-vault create vault_files/staging_secrets.yml
Use the same password and add this content:

# Staging environment secrets
db_username: staging_user
db_password: staging_pass_456
db_host: staging-db.local
db_port: 5432
db_name: staging_db

# Staging API configuration
api_endpoint: https://staging-api.example.com
api_key: staging_key_789
Subtask 2.5: Encrypt Existing Plain Text Files
Create a plain text file first, then encrypt it.

# Create a plain text file with secrets
cat > vault_files/plain_secrets.yml << 'EOF'
# Production secrets - UNENCRYPTED
admin_email: admin@company.com
admin_password: plain_text_password
smtp_server: smtp.company.com
smtp_username: noreply@company.com
smtp_password: email_password_123
EOF

# View the plain text file
cat vault_files/plain_secrets.yml

# Encrypt the existing file
ansible-vault encrypt vault_files/plain_secrets.yml

# Verify it's now encrypted
cat vault_files/plain_secrets.yml
Subtask 2.6: Working with Vault IDs
For better organization, let's use vault IDs to manage multiple vault files.

# Create a vault file with a specific vault ID
ansible-vault create --vault-id production@prompt vault_files/production_secrets.yml
When prompted for the vault ID password, use: ProductionPass456

Add this content:

# Production environment with vault ID
db_username: prod_admin
db_password: prod_ultra_secure_pass_789
db_host: prod-db-cluster.internal
db_port: 5432
db_name: production_main

# Production monitoring
monitoring_api_key: prod_monitor_key_abc123
alert_webhook: https://alerts.company.com/webhook
Task 3: Decrypt and Use Vault Data in Playbooks
Subtask 3.1: Create a Basic Playbook Using Vault Variables
Let's create a playbook that uses our encrypted variables.

# Create a playbook that uses vault variables
cat > playbooks/database_setup.yml << 'EOF'
---
- name: Database Configuration Playbook
  hosts: local
  vars_files:
    - ../vault_files/database_secrets.yml
  tasks:
    - name: Display database connection info (masked)
      debug:
        msg: "Connecting to database {{ db_name }} on {{ db_host }}:{{ db_port }}"
    
    - name: Create database configuration file
      copy:
        content: |
          [database]
          host={{ db_host }}
          port={{ db_port }}
          database={{ db_name }}
          username={{ db_username }}
          # Password is encrypted and secure
        dest: /tmp/db_config.ini
        mode: '0600'
    
    - name: Verify configuration file was created
      stat:
        path: /tmp/db_config.ini
      register: config_file
    
    - name: Show configuration file status
      debug:
        msg: "Configuration file exists: {{ config_file.stat.exists }}"
    
    - name: Display API key length (for security)
      debug:
        msg: "API key length: {{ api_key | length }} characters"
EOF
Subtask 3.2: Run Playbook with Vault Password
# Run the playbook with vault password prompt
ansible-playbook -i inventory/hosts playbooks/database_setup.yml --ask-vault-pass

# Alternative: Run with vault password file (we'll create this next)
Subtask 3.3: Create and Use Vault Password Files
For automation purposes, you can store vault passwords in files (ensure proper file permissions).

# Create a password file (be careful with permissions)
echo "MySecretPassword123" > ~/.vault_pass
chmod 600 ~/.vault_pass

# Run playbook using password file
ansible-playbook -i inventory/hosts playbooks/database_setup.yml --vault-password-file ~/.vault_pass
Subtask 3.4: Create a Multi-Environment Playbook
# Create a playbook that can work with different environments
cat > playbooks/multi_env_setup.yml << 'EOF'
---
- name: Multi-Environment Setup
  hosts: local
  vars:
    environment: "{{ env | default('development') }}"
  vars_files:
    - "../vault_files/{{ environment }}_secrets.yml"
  tasks:
    - name: Show current environment
      debug:
        msg: "Deploying to {{ environment }} environment"
    
    - name: Display database connection details
      debug:
        msg: 
          - "Database Host: {{ db_host }}"
          - "Database Name: {{ db_name }}"
          - "Database Port: {{ db_port }}"
    
    - name: Create environment-specific config
      copy:
        content: |
          # {{ environment | upper }} ENVIRONMENT CONFIG
          # Generated on {{ ansible_date_time.iso8601 }}
          
          DATABASE_HOST={{ db_host }}
          DATABASE_PORT={{ db_port }}
          DATABASE_NAME={{ db_name }}
          DATABASE_USER={{ db_username }}
          
          # API Configuration
          API_KEY_LENGTH={{ api_key | length }}
          
        dest: "/tmp/{{ environment }}_config.env"
        mode: '0600'
    
    - name: Verify environment config
      stat:
        path: "/tmp/{{ environment }}_config.env"
      register: env_config
    
    - name: Show config file info
      debug:
        msg: "Config file for {{ environment }}: {{ env_config.stat.path }}"
EOF
Subtask 3.5: Run Multi-Environment Playbook
# Run for staging environment
ansible-playbook -i inventory/hosts playbooks/multi_env_setup.yml \
  --vault-password-file ~/.vault_pass \
  --extra-vars "env=staging"

# Check the generated config file
cat /tmp/staging_config.env
Subtask 3.6: Working with Vault IDs in Playbooks
# Create a playbook for production using vault ID
cat > playbooks/production_deploy.yml << 'EOF'
---
- name: Production Deployment
  hosts: local
  vars_files:
    - ../vault_files/production_secrets.yml
  tasks:
    - name: Production deployment notice
      debug:
        msg: "Deploying to production database: {{ db_name }}"
    
    - name: Create production monitoring config
      copy:
        content: |
          # Production Monitoring Configuration
          MONITOR_API_KEY={{ monitoring_api_key }}
          ALERT_WEBHOOK={{ alert_webhook }}
          DB_HOST={{ db_host }}
          DB_NAME={{ db_name }}
        dest: /tmp/production_monitoring.conf
        mode: '0600'
    
    - name: Verify production config
      debug:
        msg: "Production monitoring configured with API key length: {{ monitoring_api_key | length }}"
EOF

# Run with vault ID
ansible-playbook -i inventory/hosts playbooks/production_deploy.yml \
  --vault-id production@prompt
Subtask 3.7: Advanced Vault Operations
Let's explore more advanced vault operations.

# Edit an existing vault file
ansible-vault edit vault_files/database_secrets.yml --vault-password-file ~/.vault_pass

# Change vault password
ansible-vault rekey vault_files/database_secrets.yml --vault-password-file ~/.vault_pass

# Decrypt a file permanently (be careful!)
cp vault_files/staging_secrets.yml vault_files/staging_secrets_backup.yml
ansible-vault decrypt vault_files/staging_secrets_backup.yml --vault-password-file ~/.vault_pass

# View the decrypted content
cat vault_files/staging_secrets_backup.yml

# Re-encrypt it
ansible-vault encrypt vault_files/staging_secrets_backup.yml --vault-password-file ~/.vault_pass
Subtask 3.8: Create a Comprehensive Security Playbook
# Create a playbook demonstrating various vault usage patterns
cat > playbooks/security_demo.yml << 'EOF'
---
- name: Comprehensive Security Demo
  hosts: local
  vars_files:
    - ../vault_files/database_secrets.yml
  vars:
    # Mix encrypted and non-encrypted variables
    app_name: "MySecureApp"
    app_version: "1.0.0"
    deployment_time: "{{ ansible_date_time.iso8601 }}"
  tasks:
    - name: Create application directory
      file:
        path: /tmp/secure_app
        state: directory
        mode: '0755'
    
    - name: Generate secure configuration
      template:
        content: |
          # {{ app_name }} Configuration
          # Version: {{ app_version }}
          # Deployed: {{ deployment_time }}
          
          [application]
          name={{ app_name }}
          version={{ app_version }}
          
          [database]
          host={{ db_host }}
          port={{ db_port }}
          name={{ db_name }}
          user={{ db_username }}
          # Password stored securely in vault
          
          [security]
          api_key_configured=true
          ssl_cert={{ ssl_cert_path }}
          ssl_key={{ ssl_key_path }}
          
          [monitoring]
          secret_token_length={{ secret_token | length }}
        dest: /tmp/secure_app/app.conf
        mode: '0600'
    
    - name: Create startup script with secure handling
      copy:
        content: |
          #!/bin/bash
          # Secure application startup script
          
          echo "Starting {{ app_name }} v{{ app_version }}"
          echo "Database: {{ db_host }}:{{ db_port }}/{{ db_name }}"
          echo "SSL Certificate: {{ ssl_cert_path }}"
          
          # Note: Actual passwords never echoed or logged
          echo "Configuration loaded securely from vault"
          
          # Simulate application startup
          echo "Application started successfully"
        dest: /tmp/secure_app/start.sh
        mode: '0755'
    
    - name: Run the startup script
      command: /tmp/secure_app/start.sh
      register: startup_output
    
    - name: Show startup output
      debug:
        var: startup_output.stdout_lines
    
    - name: Security audit - check file permissions
      find:
        paths: /tmp/secure_app
        file_type: file
      register: app_files
    
    - name: Display file security info
      debug:
        msg: "File: {{ item.path }}, Mode: {{ item.mode }}, Size: {{ item.size }} bytes"
      loop: "{{ app_files.files }}"
EOF

# Run the comprehensive security demo
ansible-playbook -i inventory/hosts playbooks/security_demo.yml --vault-password-file ~/.vault_pass
Subtask 3.9: Vault Best Practices Implementation
# Create a playbook demonstrating best practices
cat > playbooks/vault_best_practices.yml << 'EOF'
---
- name: Ansible Vault Best Practices Demo
  hosts: local
  vars_files:
    - ../vault_files/database_secrets.yml
  vars:
    # Non-sensitive configuration
    log_level: "INFO"
    max_connections: 100
    timeout_seconds: 30
  tasks:
    - name: Best Practice 1 - Never log sensitive data
      debug:
        msg: "Database configured for {{ db_name }} (password hidden)"
      # NEVER do: debug: var=db_password
    
    - name: Best Practice 2 - Use no_log for sensitive tasks
      shell: echo "Connecting with password {{ db_password }}"
      register: connection_result
      no_log: true
      changed_when: false
    
    - name: Best Practice 3 - Validate vault variables exist
      assert:
        that:
          - db_username is defined
          - db_password is defined
          - db_host is defined
          - api_key is defined
        fail_msg: "Required vault variables are missing"
        success_msg: "All required vault variables are present"
    
    - name: Best Practice 4 - Use secure file permissions
      copy:
        content: |
          # Secure configuration - restricted access
          DB_USER={{ db_username }}
          DB_HOST={{ db_host }}
          # Password managed securely
        dest: /tmp/secure_config.conf
        mode: '0600'  # Owner read/write only
        owner: "{{ ansible_user_id }}"
    
    - name: Best Practice 5 - Verify secure permissions
      stat:
        path: /tmp/secure_config.conf
      register: secure_file
    
    - name: Show file security status
      debug:
        msg: 
          - "File mode: {{ secure_file.stat.mode }}"
          - "Owner: {{ secure_file.stat.pw_name }}"
          - "Readable by others: {{ secure_file.stat.readable }}"
    
    - name: Best Practice 6 - Clean up sensitive data
      file:
        path: /tmp/secure_config.conf
        state: absent
      when: cleanup_enabled | default(true)
EOF

# Run best practices demo
ansible-playbook -i inventory/hosts playbooks/vault_best_practices.yml --vault-password-file ~/.vault_pass
Task 4: Advanced Vault Management and Troubleshooting
Subtask 4.1: Vault File Management
# List all vault files and their status
find ~/ansible-vault-lab/vault_files -name "*.yml" -exec echo "File: {}" \; -exec ansible-vault view {} --vault-password-file ~/.vault_pass \; 2>/dev/null || echo "Could not decrypt {}"

# Create a vault inventory script
cat > scripts/vault_inventory.sh << 'EOF'
#!/bin/bash
# Vault inventory management script

VAULT_DIR="$HOME/ansible-vault-lab/vault_files"
VAULT_PASS_FILE="$HOME/.vault_pass"

echo "=== Ansible Vault Inventory ==="
echo "Vault Directory: $VAULT_DIR"
echo "================================"

for vault_file in "$VAULT_DIR"/*.yml; do
    if [ -f "$vault_file" ]; then
        echo "File: $(basename "$vault_file")"
        echo "Size: $(stat -c%s "$vault_file") bytes"
        echo "Modified: $(stat -c%y "$vault_file")"
        
        # Try to get variable count
        var_count=$(ansible-vault view "$vault_file" --vault-password-file "$VAULT_PASS_FILE" 2>/dev/null | grep -c "^[a-zA-Z]" || echo "encrypted")
        echo "Variables: $var_count"
        echo "---"
    fi
done
EOF

chmod +x scripts/vault_inventory.sh
mkdir -p scripts
mv scripts/vault_inventory.sh scripts/
./scripts/vault_inventory.sh
Subtask 4.2: Troubleshooting Common Vault Issues
# Create a troubleshooting playbook
cat > playbooks/vault_troubleshooting.yml << 'EOF'
---
- name: Vault Troubleshooting and Diagnostics
  hosts: local
  vars_files:
    - ../vault_files/database_secrets.yml
  tasks:
    - name: Test 1 - Verify vault variables are accessible
      debug:
        msg: "Vault variables loaded successfully"
      when: db_username is defined and db_password is defined
    
    - name: Test 2 - Check variable types
      debug:
        msg: 
          - "db_username type: {{ db_username | type_debug }}"
          - "db_password type: {{ db_password | type_debug }}"
          - "db_port type: {{ db_port | type_debug }}"
    
    - name: Test 3 - Validate non-empty values
      assert:
        that:
          - db_username | length > 0
          - db_password | length > 0
          - db_host | length > 0
        fail_msg: "One or more vault variables are empty"
        success_msg: "All vault variables have values"
    
    - name: Test 4 - Create test connection string
      set_fact:
        connection_string: "postgresql://{{ db_username }}:***@{{ db_host }}:{{ db_port }}/{{ db_name }}"
    
    - name: Test 5 - Display masked connection info
      debug:
        msg: "Connection string format: {{ connection_string }}"
    
    - name: Test 6 - Write diagnostic info
      copy:
        content: |
          Vault Diagnostic Report
          Generated: {{ ansible_date_time.iso8601 }}
          
          Variables Status:
          - db_username: {{ 'OK' if db_username is defined else 'MISSING' }}
          - db_password: {{ 'OK' if db_password is defined else 'MISSING' }}
          - db_host: {{ 'OK' if db_host is defined else 'MISSING' }}
          - db_port: {{ 'OK' if db_port is defined else 'MISSING' }}
          - db_name: {{ 'OK' if db_name is defined else 'MISSING' }}
          - api_key: {{ 'OK' if api_key is defined else 'MISSING' }}
          
          Security Check:
          - Password length: {{ db_password | length }} characters
          - API key length: {{ api_key | length }} characters
          
        dest: /tmp/vault_diagnostic.txt
        mode: '0600'
EOF

# Run troubleshooting playbook
ansible-playbook -i inventory/hosts playbooks/vault_troubleshooting.yml --vault-password-file ~/.vault_pass

# View diagnostic report
cat /tmp/vault_diagnostic.txt
Subtask 4.3: Backup and Recovery Procedures
# Create backup script for vault files
cat > scripts/vault_backup.sh << 'EOF'
#!/bin/bash
# Vault backup script

VAULT_DIR="$HOME/ansible-vault-lab/vault_files"
BACKUP_DIR="$HOME/ansible-vault-lab/backups"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_NAME="vault_backup_$TIMESTAMP"

# Create backup directory
mkdir -p "$BACKUP_DIR/$BACKUP_NAME"

echo "Creating vault backup: $BACKUP_NAME"

# Copy all vault files
cp "$VAULT_DIR"/*.yml "$BACKUP_DIR/$BACKUP_NAME/" 2>/dev/null || echo "No vault files to backup"

# Create backup manifest
cat > "$BACKUP_DIR/$BACKUP_NAME/manifest.txt" << EOL
Vault Backup Manifest
Created: $(date)
Source: $VAULT_DIR
Files backed up:
EOL

ls -la "$BACKUP_DIR/$BACKUP_NAME"/*.yml >> "$BACKUP_DIR/$BACKUP_NAME/manifest.txt" 2>/dev/null

echo "Backup completed: $BACKUP_DIR/$BACKUP_NAME"
echo "Files in backup:"
ls -la "$BACKUP_DIR/$BACKUP_NAME/"
EOF

chmod +x scripts/vault_backup.sh
./scripts/vault_backup.sh
Subtask 4.4: Performance and Security Validation
# Create a comprehensive validation playbook
cat > playbooks/vault_validation.yml << 'EOF'
---
- name: Comprehensive Vault Validation
  hosts: local
  vars_files:
    - ../vault_files/database_secrets.yml
    - ../vault_files/staging_secrets.yml
  tasks:
    - name: Performance Test - Variable Access Speed
      debug:
        msg: "Accessing vault variables..."
      with_items:
        - "{{ db_username }}"
        - "{{ db_host }}"
        - "{{ db_name }}"
      loop_control:
        loop_var: vault_var
      no_log: true
    
    - name: Security Test - Verify no plain text passwords in memory
      shell: ps aux | grep -i ansible | grep -v grep
      register: process_check
      changed_when: false
    
    - name: Security Test - Check for password in process list
      assert:
        that: 
          - "'MySecretPassword123' not in process_check.stdout"
          - "'super_secret_password' not in process_check.stdout"
        success_msg: "No passwords found in process list"
        fail_msg: "WARNING: Passwords may be visible in process list"
    
    - name: Functionality Test - Variable Interpolation
      set_fact:
        test_config: |
          [database]
          host={{ db_host }}
          port={{ db_port }}
          name={{ db_name }}
          user={{ db_username }}
    
    - name: Functionality Test - Verify interpolation worked
      assert:
        that:
          - "'localhost' in test_config"
          - "'production_db' in test_config"
        success_msg: "Variable interpolation working correctly"
    
    - name: Integration Test - Multiple vault files
      debug:
        msg: 
          - "Production DB: {{ db_name }}"
          - "Staging DB: {{ hostvars[inventory_hostname]['db_name'] }}"
      vars:
        # This demonstrates accessing variables from different vault files
        staging_db: "{{ hostvars[inventory_hostname]['db_name'] }}"
    
    - name: Final Validation Summary
      debug:
        msg:
          - "=== Vault Validation Complete ==="
          - "✓ Variable access: PASSED"
          - "✓ Security check: PASSED"
          - "✓ Interpolation: PASSED"
          - "✓ Multi-file support: PASSED"
          - "=== All tests successful ==="
EOF

# Run comprehensive validation
ansible-playbook -i inventory/hosts playbooks/vault_validation.yml --vault-password-file ~/.vault_pass
Lab Summary and Cleanup
Final Verification
Let's verify everything we've accomplished:

# Show all files created during the lab
echo "=== Lab Files Created ==="
find ~/ansible-vault-lab -type f -name "*.yml" -o -name "*.sh" -o -name "*.txt" -o -name "*.conf" | sort

# Show vault files specifically
echo -e "\n=== Vault Files ==="
ls -la ~/ansible-vault-lab/vault_files/

# Show generated configuration files
echo -e "\n=== Generated Config Files ==="
ls -la /tmp/*config* /tmp/*monitoring* 2>/dev/null || echo "No config files found"

# Final security check
echo -e "\n=== Security Check ==="
echo "Vault password file permissions:"
ls -la ~/.vault_pass
Optional Cleanup
If you want to clean up the lab environment:

# Remove temporary files (optional)
rm -f /tmp/*config* /tmp/*monitoring* /tmp/vault_diagnostic.txt

# Remove lab directory (optional - only if you're completely done)
# rm -rf ~/ansible-vault-lab

# Remove vault password file (optional - be careful!)
# rm ~/.vault_pass
Conclusion
Congratulations! You have successfully completed Lab 6: Secure Secrets Management with Ansible Vault. In this comprehensive lab, you have accomplished the following:

Key Achievements:

Mastered Ansible Vault Fundamentals: You learned how to create, encrypt, and manage sensitive data using ansible-vault commands, understanding the critical importance of securing credentials and sensitive information in automation workflows.

Implemented Secure Data Encryption: You successfully created multiple encrypted vault files containing database credentials, API keys, and other sensitive configuration data, demonstrating proper encryption techniques.

Integrated Vault Data in Playbooks: You developed and executed multiple Ansible playbooks that securely consume encrypted vault data, showing how to maintain security while enabling automation functionality.

Applied Security Best Practices: You implemented industry-standard security practices including proper file permissions, avoiding logging of sensitive data, and secure variable handling in automation scripts.

Explored Advanced Vault Features: You worked with vault IDs, multiple vault files, password files, and complex multi-environment scenarios, preparing you for real-world enterprise automation challenges.

Why This Matters:

In today's cybersecurity landscape, protecting sensitive data is not optional—it's essential. Ansible Vault provides a robust solution for maintaining security in Infrastructure as Code (IaC) environments. The skills you've developed enable you to:

Secure credentials and sensitive data in version control systems
Implement automated deployments without compromising security
Meet compliance requirements for data protection
Scale secure automation across multiple environments
Maintain audit trails for sensitive data access
Real-World Applications:

The techniques you've learned are directly applicable to:

DevOps Pipelines: Securing CI/CD workflows with encrypted credentials
Cloud Deployments: Managing API keys and certificates securely
Database Management: Protecting connection strings and passwords
Multi-Environment Operations: Maintaining separate secure configurations for development, staging, and production
Compliance Requirements: Meeting security standards like SOC 2, PCI DSS, and GDPR
You now have the foundational knowledge and practical experience to implement secure secrets management in professional Ansible environments, making you a valuable asset in any organization prioritizing security and automation.