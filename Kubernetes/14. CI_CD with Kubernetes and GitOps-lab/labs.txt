Lab 14: CI/CD with Kubernetes and GitOps
Learning Objectives
By the end of this lab, students will be able to:

Set up a complete CI/CD pipeline using Jenkins and Kubernetes on a single Linux machine
Implement GitOps practices for automated application deployment
Configure Jenkins to build Docker images and deploy to Kubernetes
Create and manage Kubernetes manifests for application deployment
Understand the GitOps workflow and its benefits for continuous deployment
Monitor and troubleshoot CI/CD pipeline issues
Implement automated testing and deployment strategies
Prerequisites
Before starting this lab, students should have:

Basic understanding of Linux command line operations
Familiarity with Docker containers and containerization concepts
Basic knowledge of Kubernetes concepts (pods, services, deployments)
Understanding of Git version control system
Basic knowledge of YAML file structure
Familiarity with CI/CD concepts and practices
Lab Environment
Al Nafi provides Linux-based cloud machines for this lab. Simply click Start Lab to access your dedicated Linux machine. The provided Linux machine is bare metal with no pre-installed tools, so you will need to install all required tools during the lab following the step-by-step instructions provided.

Task 1: Setting Up the Development Environment
Subtask 1.1: Install Required Dependencies
First, we need to install all the necessary tools on our Linux machine.

# Update the system
sudo apt update && sudo apt upgrade -y

# Install essential packages
sudo apt install -y curl wget git vim nano software-properties-common apt-transport-https ca-certificates gnupg lsb-release

# Install Docker
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt update
sudo apt install -y docker-ce docker-ce-cli containerd.io

# Add current user to docker group
sudo usermod -aG docker $USER
newgrp docker

# Verify Docker installation
docker --version
Subtask 1.2: Install Kubernetes (minikube)
# Install kubectl
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl

# Install minikube
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube

# Start minikube
minikube start --driver=docker

# Verify Kubernetes installation
kubectl cluster-info
kubectl get nodes
Subtask 1.3: Install Jenkins
# Install Java (required for Jenkins)
sudo apt install -y openjdk-11-jdk

# Add Jenkins repository
curl -fsSL https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key | sudo tee /usr/share/keyrings/jenkins-keyring.asc > /dev/null
echo deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] https://pkg.jenkins.io/debian-stable binary/ | sudo tee /etc/apt/sources.list.d/jenkins.list > /dev/null

# Install Jenkins
sudo apt update
sudo apt install -y jenkins

# Start Jenkins service
sudo systemctl start jenkins
sudo systemctl enable jenkins

# Get Jenkins initial admin password
sudo cat /var/lib/jenkins/secrets/initialAdminPassword
Subtask 1.4: Install ArgoCD for GitOps
# Create ArgoCD namespace
kubectl create namespace argocd

# Install ArgoCD
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

# Wait for ArgoCD pods to be ready
kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd

# Get ArgoCD admin password
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d && echo
Task 2: Create Sample Application and Repository Structure
Subtask 2.1: Create Sample Node.js Application
# Create project directory
mkdir -p ~/cicd-lab/sample-app
cd ~/cicd-lab/sample-app

# Create package.json
cat > package.json << 'EOF'
{
  "name": "sample-nodejs-app",
  "version": "1.0.0",
  "description": "Sample Node.js application for CI/CD lab",
  "main": "app.js",
  "scripts": {
    "start": "node app.js",
    "test": "echo \"Running tests...\" && exit 0"
  },
  "dependencies": {
    "express": "^4.18.2"
  }
}
EOF

# Create main application file
cat > app.js << 'EOF'
const express = require('express');
const app = express();
const port = process.env.PORT || 3000;

app.get('/', (req, res) => {
  res.json({
    message: 'Hello from CI/CD Lab!',
    version: '1.0.0',
    timestamp: new Date().toISOString()
  });
});

app.get('/health', (req, res) => {
  res.json({ status: 'healthy' });
});

app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});
EOF

# Create Dockerfile
cat > Dockerfile << 'EOF'
FROM node:16-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install --only=production

COPY . .

EXPOSE 3000

USER node

CMD ["npm", "start"]
EOF

# Create .dockerignore
cat > .dockerignore << 'EOF'
node_modules
npm-debug.log
.git
.gitignore
README.md
EOF
Subtask 2.2: Create Kubernetes Manifests
# Create k8s directory
mkdir -p ~/cicd-lab/k8s-manifests

# Create deployment manifest
cat > ~/cicd-lab/k8s-manifests/deployment.yaml << 'EOF'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sample-app
  labels:
    app: sample-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: sample-app
  template:
    metadata:
      labels:
        app: sample-app
    spec:
      containers:
      - name: sample-app
        image: sample-app:latest
        ports:
        - containerPort: 3000
        env:
        - name: PORT
          value: "3000"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
EOF

# Create service manifest
cat > ~/cicd-lab/k8s-manifests/service.yaml << 'EOF'
apiVersion: v1
kind: Service
metadata:
  name: sample-app-service
spec:
  selector:
    app: sample-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 3000
  type: ClusterIP
EOF

# Create namespace manifest
cat > ~/cicd-lab/k8s-manifests/namespace.yaml << 'EOF'
apiVersion: v1
kind: Namespace
metadata:
  name: sample-app
EOF
Subtask 2.3: Initialize Git Repository
# Initialize git repository
cd ~/cicd-lab
git init
git config user.name "Lab Student"
git config user.email "student@example.com"

# Create .gitignore
cat > .gitignore << 'EOF'
node_modules/
*.log
.DS_Store
.env
EOF

# Add and commit files
git add .
git commit -m "Initial commit: Sample Node.js app with Kubernetes manifests"
Task 3: Configure Jenkins CI Pipeline
Subtask 3.1: Access and Configure Jenkins
# Get Jenkins URL (it runs on port 8080)
echo "Jenkins URL: http://localhost:8080"

# Port forward to access Jenkins (run in a new terminal)
kubectl port-forward --address 0.0.0.0 svc/jenkins 8080:8080 &

# Note: In a real environment, you would access Jenkins via browser
# For this lab, we'll configure Jenkins via CLI and files
Subtask 3.2: Install Jenkins Plugins
# Download Jenkins CLI
wget http://localhost:8080/jnlpJars/jenkins-cli.jar

# Wait for Jenkins to be fully ready
sleep 30

# Install required plugins (this requires Jenkins to be accessible)
# We'll create a plugins list file instead
cat > ~/jenkins-plugins.txt << 'EOF'
kubernetes
docker-workflow
git
pipeline-stage-view
workflow-aggregator
EOF
Subtask 3.3: Create Jenkins Pipeline Script
# Create Jenkinsfile for the pipeline
cat > ~/cicd-lab/Jenkinsfile << 'EOF'
pipeline {
    agent any
    
    environment {
        DOCKER_IMAGE = 'sample-app'
        DOCKER_TAG = "${BUILD_NUMBER}"
        KUBECONFIG = '/var/lib/jenkins/.kube/config'
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
                echo 'Code checked out successfully'
            }
        }
        
        stage('Test') {
            steps {
                dir('sample-app') {
                    sh 'npm install'
                    sh 'npm test'
                }
            }
        }
        
        stage('Build Docker Image') {
            steps {
                dir('sample-app') {
                    script {
                        def image = docker.build("${DOCKER_IMAGE}:${DOCKER_TAG}")
                        docker.withRegistry('', '') {
                            image.push()
                            image.push('latest')
                        }
                    }
                }
            }
        }
        
        stage('Update Kubernetes Manifests') {
            steps {
                script {
                    sh """
                        sed -i 's|image: sample-app:.*|image: sample-app:${DOCKER_TAG}|g' k8s-manifests/deployment.yaml
                        git add k8s-manifests/deployment.yaml
                        git commit -m "Update image tag to ${DOCKER_TAG}" || true
                    """
                }
            }
        }
        
        stage('Deploy to Kubernetes') {
            steps {
                sh '''
                    kubectl apply -f k8s-manifests/namespace.yaml
                    kubectl apply -f k8s-manifests/ -n sample-app
                    kubectl rollout status deployment/sample-app -n sample-app
                '''
            }
        }
    }
    
    post {
        always {
            cleanWs()
        }
        success {
            echo 'Pipeline completed successfully!'
        }
        failure {
            echo 'Pipeline failed!'
        }
    }
}
EOF
Subtask 3.4: Configure Jenkins for Kubernetes Access
# Copy kubeconfig to Jenkins
sudo mkdir -p /var/lib/jenkins/.kube
sudo cp ~/.kube/config /var/lib/jenkins/.kube/config
sudo chown -R jenkins:jenkins /var/lib/jenkins/.kube

# Add Jenkins user to docker group
sudo usermod -aG docker jenkins

# Restart Jenkins to apply changes
sudo systemctl restart jenkins
Task 4: Implement GitOps with ArgoCD
Subtask 4.1: Access ArgoCD
# Port forward ArgoCD server
kubectl port-forward svc/argocd-server -n argocd 8080:443 &

# Get ArgoCD admin password (save this)
ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
echo "ArgoCD Admin Password: $ARGOCD_PASSWORD"

# Install ArgoCD CLI
curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
rm argocd-linux-amd64
Subtask 4.2: Create ArgoCD Application
# Login to ArgoCD CLI
argocd login localhost:8080 --username admin --password $ARGOCD_PASSWORD --insecure

# Create ArgoCD application manifest
cat > ~/cicd-lab/argocd-app.yaml << 'EOF'
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: sample-app
  namespace: argocd
spec:
  project: default
  source:
    repoURL: file:///home/ubuntu/cicd-lab
    targetRevision: HEAD
    path: k8s-manifests
  destination:
    server: https://kubernetes.default.svc
    namespace: sample-app
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
    - CreateNamespace=true
EOF

# Apply ArgoCD application
kubectl apply -f ~/cicd-lab/argocd-app.yaml
Subtask 4.3: Configure Git Repository for GitOps
# Create a separate GitOps repository structure
mkdir -p ~/cicd-lab/gitops-repo/environments/dev
mkdir -p ~/cicd-lab/gitops-repo/environments/prod

# Copy manifests to GitOps repo
cp ~/cicd-lab/k8s-manifests/* ~/cicd-lab/gitops-repo/environments/dev/

# Create environment-specific configurations
cat > ~/cicd-lab/gitops-repo/environments/dev/kustomization.yaml << 'EOF'
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
- namespace.yaml
- deployment.yaml
- service.yaml

namePrefix: dev-
namespace: sample-app-dev

replicas:
- name: sample-app
  count: 1
EOF

# Update ArgoCD app to use GitOps repo
cat > ~/cicd-lab/argocd-gitops-app.yaml << 'EOF'
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: sample-app-gitops
  namespace: argocd
spec:
  project: default
  source:
    repoURL: file:///home/ubuntu/cicd-lab/gitops-repo
    targetRevision: HEAD
    path: environments/dev
  destination:
    server: https://kubernetes.default.svc
    namespace: sample-app-dev
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
    - CreateNamespace=true
EOF
Task 5: Test the Complete CI/CD Pipeline
Subtask 5.1: Build and Test the Application Locally
# Build the Docker image locally first
cd ~/cicd-lab/sample-app
docker build -t sample-app:latest .

# Test the application
docker run -d -p 3000:3000 --name test-app sample-app:latest

# Wait for container to start
sleep 5

# Test the endpoints
curl http://localhost:3000/
curl http://localhost:3000/health

# Stop and remove test container
docker stop test-app
docker rm test-app
Subtask 5.2: Deploy Application to Kubernetes
# Apply the Kubernetes manifests
kubectl apply -f ~/cicd-lab/k8s-manifests/namespace.yaml
kubectl apply -f ~/cicd-lab/k8s-manifests/ -n sample-app

# Check deployment status
kubectl get pods -n sample-app
kubectl get services -n sample-app

# Wait for deployment to be ready
kubectl wait --for=condition=available --timeout=300s deployment/sample-app -n sample-app
Subtask 5.3: Test Application in Kubernetes
# Port forward to access the application
kubectl port-forward svc/sample-app-service 3001:80 -n sample-app &

# Test the application
sleep 5
curl http://localhost:3001/
curl http://localhost:3001/health

# Check ArgoCD application status
argocd app list
argocd app get sample-app-gitops
Subtask 5.4: Simulate GitOps Workflow
# Make a change to the application
cd ~/cicd-lab/sample-app
sed -i 's/version: '\''1.0.0'\''/version: '\''1.1.0'\''/g' app.js

# Build new image
docker build -t sample-app:v1.1.0 .
docker tag sample-app:v1.1.0 sample-app:latest

# Update Kubernetes manifest
cd ~/cicd-lab
sed -i 's/image: sample-app:latest/image: sample-app:v1.1.0/g' k8s-manifests/deployment.yaml

# Commit changes
git add .
git commit -m "Update application to version 1.1.0"

# Copy updated manifests to GitOps repo
cp k8s-manifests/deployment.yaml gitops-repo/environments/dev/

# Sync ArgoCD application
argocd app sync sample-app-gitops

# Check if the update was applied
kubectl get pods -n sample-app-dev
kubectl rollout status deployment/dev-sample-app -n sample-app-dev
Task 6: Monitor and Verify the Pipeline
Subtask 6.1: Check Application Health
# Check all running pods
kubectl get pods --all-namespaces

# Check application logs
kubectl logs -l app=sample-app -n sample-app --tail=50

# Check ArgoCD application health
argocd app get sample-app-gitops

# Verify application is responding
kubectl port-forward svc/dev-sample-app-service 3002:80 -n sample-app-dev &
sleep 5
curl http://localhost:3002/
Subtask 6.2: View ArgoCD Dashboard
# Get ArgoCD server status
kubectl get pods -n argocd

# Access ArgoCD UI information
echo "ArgoCD URL: https://localhost:8080"
echo "Username: admin"
echo "Password: $ARGOCD_PASSWORD"

# List all applications
argocd app list

# Get detailed application information
argocd app get sample-app-gitops --output yaml
Subtask 6.3: Verify GitOps Principles
# Show Git history
cd ~/cicd-lab
git log --oneline

# Show current state of manifests
cat k8s-manifests/deployment.yaml | grep image:

# Show ArgoCD sync status
argocd app sync sample-app-gitops --dry-run

# Verify declarative configuration
kubectl get deployment dev-sample-app -n sample-app-dev -o yaml | grep image:
Task 7: Implement Advanced GitOps Features
Subtask 7.1: Create Multi-Environment Setup
# Create production environment
mkdir -p ~/cicd-lab/gitops-repo/environments/prod
cp ~/cicd-lab/k8s-manifests/* ~/cicd-lab/gitops-repo/environments/prod/

# Create production kustomization
cat > ~/cicd-lab/gitops-repo/environments/prod/kustomization.yaml << 'EOF'
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
- namespace.yaml
- deployment.yaml
- service.yaml

namePrefix: prod-
namespace: sample-app-prod

replicas:
- name: sample-app
  count: 3

images:
- name: sample-app
  newTag: v1.0.0
EOF

# Create production ArgoCD application
cat > ~/cicd-lab/argocd-prod-app.yaml << 'EOF'
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: sample-app-prod
  namespace: argocd
spec:
  project: default
  source:
    repoURL: file:///home/ubuntu/cicd-lab/gitops-repo
    targetRevision: HEAD
    path: environments/prod
  destination:
    server: https://kubernetes.default.svc
    namespace: sample-app-prod
  syncPolicy:
    syncOptions:
    - CreateNamespace=true
EOF

# Apply production application
kubectl apply -f ~/cicd-lab/argocd-prod-app.yaml
Subtask 7.2: Implement Health Checks and Monitoring
# Create monitoring namespace
kubectl create namespace monitoring

# Create a simple monitoring setup
cat > ~/cicd-lab/monitoring.yaml << 'EOF'
apiVersion: v1
kind: ConfigMap
metadata:
  name: monitoring-config
  namespace: monitoring
data:
  check-apps.sh: |
    #!/bin/bash
    echo "Checking application health..."
    kubectl get pods -n sample-app-dev
    kubectl get pods -n sample-app-prod
    echo "Health check completed"
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: health-check
  namespace: monitoring
spec:
  schedule: "*/5 * * * *"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: health-checker
            image: bitnami/kubectl:latest
            command:
            - /bin/bash
            - -c
            - |
              kubectl get pods --all-namespaces
              kubectl get applications -n argocd
          restartPolicy: OnFailure
EOF

# Apply monitoring configuration
kubectl apply -f ~/cicd-lab/monitoring.yaml
Subtask 7.3: Test Rollback Scenario
# Create a problematic version
cd ~/cicd-lab/sample-app
cat > app.js << 'EOF'
const express = require('express');
const app = express();
const port = process.env.PORT || 3000;

app.get('/', (req, res) => {
  // Simulate an error
  throw new Error('Simulated application error');
});

app.get('/health', (req, res) => {
  res.json({ status: 'healthy' });
});

app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});
EOF

# Build problematic version
docker build -t sample-app:v1.2.0-broken .

# Update manifest with broken version
cd ~/cicd-lab
sed -i 's/image: sample-app:v1.1.0/image: sample-app:v1.2.0-broken/g' gitops-repo/environments/dev/deployment.yaml

# Commit the change
git add .
git commit -m "Deploy broken version v1.2.0"

# Sync ArgoCD
argocd app sync sample-app-gitops

# Wait and check if pods are failing
sleep 30
kubectl get pods -n sample-app-dev

# Rollback by reverting the commit
git revert HEAD --no-edit

# Update GitOps repo
cp k8s-manifests/deployment.yaml gitops-repo/environments/dev/

# Sync again to rollback
argocd app sync sample-app-gitops

# Verify rollback
kubectl rollout status deployment/dev-sample-app -n sample-app-dev
Troubleshooting Common Issues
Issue 1: Jenkins Cannot Access Docker
# Solution: Ensure Jenkins user is in docker group
sudo usermod -aG docker jenkins
sudo systemctl restart jenkins

# Verify docker access
sudo -u jenkins docker ps
Issue 2: Kubernetes Pods Not Starting
# Check pod status and logs
kubectl get pods -n sample-app --show-labels
kubectl describe pod <pod-name> -n sample-app
kubectl logs <pod-name> -n sample-app

# Check if image exists
docker images | grep sample-app
Issue 3: ArgoCD Application Not Syncing
# Check ArgoCD application status
argocd app get sample-app-gitops

# Force sync
argocd app sync sample-app-gitops --force

# Check ArgoCD server logs
kubectl logs -n argocd deployment/argocd-server
Issue 4: Port Forwarding Issues
# Kill existing port forwards
pkill -f "kubectl port-forward"

# Start fresh port forwards
kubectl port-forward svc/argocd-server -n argocd 8080:443 &
kubectl port-forward svc/sample-app-service 3001:80 -n sample-app &
Verification and Testing
Final Verification Steps
# 1. Check all namespaces and resources
kubectl get all --all-namespaces

# 2. Verify ArgoCD applications
argocd app list

# 3. Test application endpoints
curl http://localhost:3001/
curl http://localhost:3001/health

# 4. Check Git repository status
cd ~/cicd-lab
git status
git log --oneline -5

# 5. Verify Docker images
docker images | grep sample-app

# 6. Check ArgoCD sync status
argocd app get sample-app-gitops --output json | grep -E '"health"|"sync"'
Conclusion
In this comprehensive lab, you have successfully implemented a complete CI/CD pipeline with Kubernetes and GitOps practices. Here's what you accomplished:

Key Achievements:

Infrastructure Setup: You installed and configured Docker, Kubernetes (minikube), Jenkins, and ArgoCD on a single Linux machine, creating a complete DevOps environment.

Application Development: You created a sample Node.js application with proper containerization using Docker and Kubernetes manifests for deployment.

CI Pipeline Implementation: You configured Jenkins to automatically build, test, and containerize applications, implementing continuous integration best practices.

GitOps Implementation: You set up ArgoCD to manage deployments declaratively, ensuring that your Kubernetes cluster state matches your Git repository configuration.

Multi-Environment Management: You created separate development and production environments with different configurations, demonstrating environment promotion strategies.

Automated Deployment: You implemented automated deployment workflows that respond to code changes and maintain desired application state.

Monitoring and Health Checks: You added monitoring capabilities and health checks to ensure application reliability.

Rollback Capabilities: You tested and implemented rollback procedures for handling problematic deployments.

Why This Matters:

Reliability: GitOps ensures your deployments are consistent, repeatable, and auditable
Speed: Automated pipelines reduce deployment time from hours to minutes
Safety: Declarative configuration and automated rollbacks reduce human error
Scalability: The same pipeline can manage multiple applications and environments
Compliance: Git-based workflows provide complete audit trails for regulatory requirements
Real-World Applications:

This lab simulates enterprise-grade CI/CD practices used by major technology companies. The skills you've learned are directly applicable to:

Microservices deployment in production environments
Multi-team development workflows
Compliance and audit requirements
Disaster recovery and business continuity planning
Cloud-native application development
You now have hands-on experience with the complete DevOps toolchain and understand how modern software delivery pipelines work in practice. These skills are essential for DevOps engineers, platform engineers, and software developers working in cloud-native environments.