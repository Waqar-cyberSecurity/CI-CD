Lab 6: Efficient Dockerfile Creation
Lab Objectives
By the end of this lab, you will be able to:

Create and structure basic Dockerfiles for containerizing applications
Implement multi-stage builds to significantly reduce image sizes
Apply Dockerfile best practices for optimal performance and security
Build, tag, and test Docker images using command-line tools
Understand layer caching and optimization techniques
Compare image sizes before and after optimization
Prerequisites
Before starting this lab, you should have:

Basic understanding of Linux command line operations
Familiarity with text editors (nano, vim, or similar)
Basic knowledge of application development concepts
Understanding of containerization fundamentals
Lab Environment Setup
Note: Al Nafi provides Linux-based cloud machines for this lab. Simply click Start Lab to access your dedicated Linux environment. The provided machine is bare metal with no pre-installed tools, so you will install Docker and other required tools during the lab exercises.

All tasks in this lab will be performed on a single Linux machine. No additional virtual machines or remote hosts are required.

Task 1: Environment Preparation and Docker Installation
Subtask 1.1: Install Docker Engine
First, we need to install Docker on our Linux machine.

# Update the package index
sudo apt update

# Install required packages
sudo apt install -y apt-transport-https ca-certificates curl gnupg lsb-release

# Add Docker's official GPG key
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

# Set up the stable repository
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# Update package index again
sudo apt update

# Install Docker Engine
sudo apt install -y docker-ce docker-ce-cli containerd.io

# Add current user to docker group
sudo usermod -aG docker $USER

# Apply group membership (logout and login, or use newgrp)
newgrp docker
Subtask 1.2: Verify Docker Installation
# Check Docker version
docker --version

# Test Docker installation
docker run hello-world

# Check Docker system information
docker system info
Subtask 1.3: Create Lab Working Directory
# Create and navigate to lab directory
mkdir -p ~/docker-lab6
cd ~/docker-lab6

# Create subdirectories for different exercises
mkdir simple-app multi-stage-app optimized-app
Task 2: Create a Simple Dockerfile
Subtask 2.1: Create a Basic Node.js Application
Let's start by creating a simple web application that we'll containerize.

# Navigate to simple-app directory
cd ~/docker-lab6/simple-app

# Create a simple Node.js application
cat > app.js << 'EOF'
const http = require('http');
const os = require('os');

const server = http.createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/html' });
    res.end(`
        <h1>Simple Docker App</h1>
        <p>Hostname: ${os.hostname()}</p>
        <p>Platform: ${os.platform()}</p>
        <p>Architecture: ${os.arch()}</p>
        <p>Node.js Version: ${process.version}</p>
        <p>Current Time: ${new Date().toISOString()}</p>
    `);
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
EOF

# Create package.json file
cat > package.json << 'EOF'
{
  "name": "simple-docker-app",
  "version": "1.0.0",
  "description": "A simple Node.js app for Docker demonstration",
  "main": "app.js",
  "scripts": {
    "start": "node app.js"
  },
  "author": "Docker Lab Student",
  "license": "MIT"
}
EOF
Subtask 2.2: Create Your First Dockerfile
Now let's create a basic Dockerfile for our application.

# Create a basic Dockerfile
cat > Dockerfile << 'EOF'
# Use official Node.js runtime as base image
FROM node:18

# Set working directory in container
WORKDIR /usr/src/app

# Copy package.json and package-lock.json (if available)
COPY package*.json ./

# Install app dependencies
RUN npm install

# Copy app source code
COPY . .

# Expose port 3000
EXPOSE 3000

# Define command to run the application
CMD ["npm", "start"]
EOF
Subtask 2.3: Build and Test the Simple Image
# Build the Docker image
docker build -t simple-node-app:v1.0 .

# Check the image size
docker images simple-node-app:v1.0

# Run the container
docker run -d -p 3000:3000 --name simple-app-container simple-node-app:v1.0

# Test the application
curl http://localhost:3000

# Check container logs
docker logs simple-app-container

# Stop and remove the container
docker stop simple-app-container
docker rm simple-app-container
Task 3: Implement Multi-Stage Builds for Optimization
Subtask 3.1: Create a More Complex Application
Let's create a more realistic application that requires build tools.

# Navigate to multi-stage directory
cd ~/docker-lab6/multi-stage-app

# Create a TypeScript application
cat > app.ts << 'EOF'
interface ServerInfo {
    hostname: string;
    platform: string;
    architecture: string;
    nodeVersion: string;
    currentTime: string;
    uptime: number;
}

import * as http from 'http';
import * as os from 'os';

const server = http.createServer((req: http.IncomingMessage, res: http.ServerResponse) => {
    const serverInfo: ServerInfo = {
        hostname: os.hostname(),
        platform: os.platform(),
        architecture: os.arch(),
        nodeVersion: process.version,
        currentTime: new Date().toISOString(),
        uptime: Math.floor(process.uptime())
    };

    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify(serverInfo, null, 2));
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
    console.log(`TypeScript server running on port ${PORT}`);
});
EOF

# Create package.json with TypeScript dependencies
cat > package.json << 'EOF'
{
  "name": "multi-stage-app",
  "version": "1.0.0",
  "description": "Multi-stage Docker build example",
  "main": "dist/app.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/app.js"
  },
  "devDependencies": {
    "typescript": "^5.0.0",
    "@types/node": "^18.0.0"
  },
  "author": "Docker Lab Student",
  "license": "MIT"
}
EOF

# Create TypeScript configuration
cat > tsconfig.json << 'EOF'
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["*.ts"],
  "exclude": ["node_modules", "dist"]
}
EOF
Subtask 3.2: Create a Single-Stage Dockerfile (Inefficient)
First, let's create an inefficient single-stage build to compare later.

# Create inefficient Dockerfile
cat > Dockerfile.single-stage << 'EOF'
FROM node:18

WORKDIR /usr/src/app

# Copy package files
COPY package*.json ./
COPY tsconfig.json ./

# Install all dependencies (including dev dependencies)
RUN npm install

# Copy source code
COPY app.ts ./

# Build the application
RUN npm run build

# Expose port
EXPOSE 3000

# Start the application
CMD ["npm", "start"]
EOF
Subtask 3.3: Create an Optimized Multi-Stage Dockerfile
Now let's create an efficient multi-stage build.

# Create optimized multi-stage Dockerfile
cat > Dockerfile << 'EOF'
# Build stage
FROM node:18-alpine AS builder

WORKDIR /usr/src/app

# Copy package files
COPY package*.json ./
COPY tsconfig.json ./

# Install dependencies (including dev dependencies for building)
RUN npm install

# Copy source code
COPY app.ts ./

# Build the application
RUN npm run build

# Production stage
FROM node:18-alpine AS production

WORKDIR /usr/src/app

# Copy package files
COPY package*.json ./

# Install only production dependencies
RUN npm install --only=production && npm cache clean --force

# Copy built application from builder stage
COPY --from=builder /usr/src/app/dist ./dist

# Create non-root user for security
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

# Change ownership of app directory
RUN chown -R nodejs:nodejs /usr/src/app

# Switch to non-root user
USER nodejs

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD node -e "require('http').get('http://localhost:3000', (res) => { process.exit(res.statusCode === 200 ? 0 : 1) })"

# Start the application
CMD ["npm", "start"]
EOF
Subtask 3.4: Build and Compare Images
# Build single-stage image
docker build -f Dockerfile.single-stage -t typescript-app:single-stage .

# Build multi-stage image
docker build -t typescript-app:multi-stage .

# Compare image sizes
echo "=== Image Size Comparison ==="
docker images | grep typescript-app

# Get detailed size information
docker image inspect typescript-app:single-stage --format='{{.Size}}' | numfmt --to=iec
docker image inspect typescript-app:multi-stage --format='{{.Size}}' | numfmt --to=iec
Subtask 3.5: Test Multi-Stage Application
# Run the multi-stage container
docker run -d -p 3001:3000 --name multi-stage-container typescript-app:multi-stage

# Test the application
curl http://localhost:3001

# Check health status
docker inspect multi-stage-container --format='{{.State.Health.Status}}'

# View container processes
docker exec multi-stage-container ps aux

# Stop and remove container
docker stop multi-stage-container
docker rm multi-stage-container
Task 4: Explore Dockerfile Best Practices
Subtask 4.1: Create an Optimized Production Dockerfile
Let's create a comprehensive example showcasing all best practices.

# Navigate to optimized-app directory
cd ~/docker-lab6/optimized-app

# Create a Python Flask application
cat > app.py << 'EOF'
from flask import Flask, jsonify
import os
import platform
import sys
from datetime import datetime

app = Flask(__name__)

@app.route('/')
def get_info():
    return jsonify({
        'message': 'Optimized Docker Application',
        'hostname': os.uname().nodename,
        'platform': platform.platform(),
        'python_version': sys.version,
        'current_time': datetime.now().isoformat(),
        'environment': os.environ.get('ENVIRONMENT', 'development')
    })

@app.route('/health')
def health_check():
    return jsonify({'status': 'healthy'}), 200

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 5000)))
EOF

# Create requirements.txt
cat > requirements.txt << 'EOF'
Flask==2.3.3
gunicorn==21.2.0
EOF

# Create .dockerignore file
cat > .dockerignore << 'EOF'
# Git
.git
.gitignore

# Documentation
README.md
*.md

# Python
__pycache__
*.pyc
*.pyo
*.pyd
.Python
env/
venv/
.venv/
pip-log.txt
pip-delete-this-directory.txt
.tox
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.log

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# IDE
.vscode/
.idea/
*.swp
*.swo

# Temporary files
*.tmp
*.temp
EOF
Subtask 4.2: Create Best Practices Dockerfile
# Create optimized Dockerfile with all best practices
cat > Dockerfile << 'EOF'
# Use specific version and minimal base image
FROM python:3.11-slim-bullseye AS base

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PYTHONHASHSEED=random \
    PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1

# Install system dependencies in a single layer
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Create non-root user
RUN groupadd --gid 1000 appuser && \
    useradd --uid 1000 --gid appuser --shell /bin/bash --create-home appuser

# Set working directory
WORKDIR /app

# Copy requirements first for better caching
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY app.py .

# Change ownership to non-root user
RUN chown -R appuser:appuser /app

# Switch to non-root user
USER appuser

# Expose port
EXPOSE 5000

# Add health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD python -c "import requests; requests.get('http://localhost:5000/health', timeout=5)"

# Use exec form and specific command
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "--workers", "2", "--timeout", "30", "app:app"]
EOF
Subtask 4.3: Create Production-Ready Dockerfile with Multi-Stage
# Create advanced multi-stage Dockerfile
cat > Dockerfile.advanced << 'EOF'
# Build stage for dependencies
FROM python:3.11-slim-bullseye AS dependencies

ENV PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1

# Install build dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip install --user --no-cache-dir -r requirements.txt

# Production stage
FROM python:3.11-slim-bullseye AS production

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PYTHONHASHSEED=random \
    PATH="/home/appuser/.local/bin:$PATH" \
    ENVIRONMENT=production

# Create non-root user
RUN groupadd --gid 1000 appuser && \
    useradd --uid 1000 --gid appuser --shell /bin/bash --create-home appuser

# Set working directory
WORKDIR /app

# Copy Python dependencies from build stage
COPY --from=dependencies --chown=appuser:appuser /root/.local /home/appuser/.local

# Copy application code
COPY --chown=appuser:appuser app.py .

# Switch to non-root user
USER appuser

# Expose port
EXPOSE 5000

# Add labels for metadata
LABEL maintainer="Docker Lab Student" \
      version="1.0" \
      description="Optimized Python Flask application"

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD python -c "import urllib.request; urllib.request.urlopen('http://localhost:5000/health', timeout=5)"

# Use exec form
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "--workers", "2", "--timeout", "30", "app:app"]
EOF
Subtask 4.4: Build and Test Optimized Images
# Build basic optimized image
docker build -t flask-app:optimized .

# Build advanced multi-stage image
docker build -f Dockerfile.advanced -t flask-app:advanced .

# Compare all images we've built
echo "=== All Images Comparison ==="
docker images | grep -E "(simple-node-app|typescript-app|flask-app)"

# Test the optimized Flask application
docker run -d -p 5000:5000 --name flask-optimized flask-app:advanced

# Test the application endpoints
curl http://localhost:5000/
curl http://localhost:5000/health

# Check security - verify non-root user
docker exec flask-optimized whoami
docker exec flask-optimized id

# Check health status
docker inspect flask-optimized --format='{{.State.Health.Status}}'

# View container resource usage
docker stats flask-optimized --no-stream

# Stop and remove container
docker stop flask-optimized
docker rm flask-optimized
Task 5: Advanced Dockerfile Techniques and Analysis
Subtask 5.1: Create Dockerfile with Build Arguments and Environment Variables
# Create configurable Dockerfile
cat > Dockerfile.configurable << 'EOF'
# Build arguments
ARG PYTHON_VERSION=3.11
ARG APP_ENV=production

# Use build argument in FROM instruction
FROM python:${PYTHON_VERSION}-slim-bullseye

# Set build-time and runtime environment variables
ENV APP_ENV=${APP_ENV} \
    PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

# Conditional installation based on environment
RUN if [ "$APP_ENV" = "development" ] ; then \
        apt-get update && apt-get install -y --no-install-recommends \
        vim \
        curl \
        && rm -rf /var/lib/apt/lists/* ; \
    fi

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY app.py .

# Create non-root user
RUN useradd --create-home --shell /bin/bash appuser
USER appuser

EXPOSE 5000

CMD ["python", "app.py"]
EOF
Subtask 5.2: Build with Different Configurations
# Build for production (default)
docker build -f Dockerfile.configurable -t flask-app:prod .

# Build for development with different Python version
docker build -f Dockerfile.configurable \
    --build-arg PYTHON_VERSION=3.10 \
    --build-arg APP_ENV=development \
    -t flask-app:dev .

# Compare the images
docker images | grep flask-app

# Test development image (should have additional tools)
docker run --rm flask-app:dev which vim
docker run --rm flask-app:dev which curl
Subtask 5.3: Analyze Docker Image Layers
# Inspect image layers and history
docker history flask-app:advanced

# Get detailed layer information
docker image inspect flask-app:advanced | grep -A 10 "RootFS"

# Use dive tool to analyze layers (install if available)
# Note: This is optional and requires additional installation
if command -v dive &> /dev/null; then
    dive flask-app:advanced
else
    echo "Dive tool not available. Skipping detailed layer analysis."
fi
Subtask 5.4: Performance Testing and Optimization Verification
# Create a script to test image performance
cat > test_performance.sh << 'EOF'
#!/bin/bash

echo "=== Docker Image Performance Test ==="

# Function to test container startup time
test_startup_time() {
    local image=$1
    local name=$2
    
    echo "Testing startup time for $image..."
    
    start_time=$(date +%s.%N)
    docker run -d --name $name $image
    
    # Wait for container to be ready
    while ! docker exec $name python -c "import requests; requests.get('http://localhost:5000/health')" 2>/dev/null; do
        sleep 0.1
    done
    
    end_time=$(date +%s.%N)
    startup_time=$(echo "$end_time - $start_time" | bc -l)
    
    echo "Startup time: ${startup_time} seconds"
    
    # Cleanup
    docker stop $name >/dev/null 2>&1
    docker rm $name >/dev/null 2>&1
}

# Test different images
test_startup_time "flask-app:optimized" "test-optimized"
test_startup_time "flask-app:advanced" "test-advanced"

echo "=== Performance test completed ==="
EOF

# Make script executable and run it
chmod +x test_performance.sh
./test_performance.sh
Task 6: Docker Build Optimization and Caching
Subtask 6.1: Demonstrate Build Cache Efficiency
# Create a new directory for cache demonstration
mkdir -p ~/docker-lab6/cache-demo
cd ~/docker-lab6/cache-demo

# Create application files
cat > app.py << 'EOF'
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return "Hello from cached build!"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
EOF

cat > requirements.txt << 'EOF'
Flask==2.3.3
EOF

# Create Dockerfile optimized for caching
cat > Dockerfile << 'EOF'
FROM python:3.11-slim

WORKDIR /app

# Copy requirements first (changes less frequently)
COPY requirements.txt .

# Install dependencies (this layer will be cached)
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code (changes more frequently)
COPY app.py .

EXPOSE 5000
CMD ["python", "app.py"]
EOF
Subtask 6.2: Test Build Caching
# First build (no cache)
echo "=== First build (no cache) ==="
time docker build -t cache-demo:v1 .

# Second build (should use cache)
echo "=== Second build (should use cache) ==="
time docker build -t cache-demo:v2 .

# Modify only the application code
cat > app.py << 'EOF'
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return "Hello from cached build - MODIFIED!"

@app.route('/new')
def new_endpoint():
    return "New endpoint added!"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
EOF

# Third build (should cache requirements layer)
echo "=== Third build (app modified, requirements cached) ==="
time docker build -t cache-demo:v3 .
Subtask 6.3: Build Context Optimization
# Create .dockerignore for build context optimization
cat > .dockerignore << 'EOF'
# Ignore unnecessary files to reduce build context
*.md
.git
.gitignore
__pycache__
*.pyc
.pytest_cache
.coverage
*.log
.DS_Store
Thumbs.db
EOF

# Show build context size
echo "=== Build context analysis ==="
docker build --no-cache -t context-demo . 2>&1 | grep "Sending build context"
Task 7: Security Best Practices Implementation
Subtask 7.1: Create Security-Hardened Dockerfile
# Create final security-hardened example
cd ~/docker-lab6
mkdir security-demo
cd security-demo

# Create application
cat > app.py << 'EOF'
from flask import Flask, jsonify
import os

app = Flask(__name__)

@app.route('/')
def secure_app():
    return jsonify({
        'message': 'Security-hardened application',
        'user': os.getenv('USER', 'unknown'),
        'uid': os.getuid(),
        'gid': os.getgid()
    })

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
EOF

cat > requirements.txt << 'EOF'
Flask==2.3.3
EOF

# Create security-focused Dockerfile
cat > Dockerfile << 'EOF'
# Use specific version with known security updates
FROM python:3.11.6-slim-bullseye

# Set security-focused environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PYTHONHASHSEED=random \
    PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1

# Update system packages and remove package manager cache
RUN apt-get update && \
    apt-get upgrade -y && \
    apt-get install -y --no-install-recommends \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/* \
    && rm -rf /tmp/* \
    && rm -rf /var/tmp/*

# Create non-root user with specific UID/GID
RUN groupadd --gid 10001 appgroup && \
    useradd --uid 10001 --gid appgroup --shell /bin/bash --create-home appuser

# Set working directory with proper permissions
WORKDIR /app
RUN chown appuser:appgroup /app

# Switch to non-root user for dependency installation
USER appuser

# Copy and install dependencies
COPY --chown=appuser:appgroup requirements.txt .
RUN pip install --user --no-cache-dir -r requirements.txt

# Copy application code
COPY --chown=appuser:appgroup app.py .

# Set PATH to include user-installed packages
ENV PATH="/home/appuser/.local/bin:$PATH"

# Expose port (non-privileged)
EXPOSE 5000

# Add security labels
LABEL security.scan="enabled" \
      security.non-root="true" \
      security.no-new-privileges="true"

# Health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \
    CMD python -c "import urllib.request; urllib.request.urlopen('http://localhost:5000', timeout=3)"

# Run with security options
CMD ["python", "app.py"]
EOF
Subtask 7.2: Build and Test Security Features
# Build security-hardened image
docker build -t secure-app:latest .

# Run with additional security options
docker run -d \
    --name secure-container \
    --read-only \
    --tmpfs /tmp \
    --tmpfs /var/tmp \
    --cap-drop ALL \
    --cap-add NET_BIND_SERVICE \
    --no-new-privileges \
    --user 10001:10001 \
    -p 5000:5000 \
    secure-app:latest

# Test the secure application
curl http://localhost:5000

# Verify security settings
docker exec secure-container id
docker exec secure-container whoami

# Check that filesystem is read-only
docker exec secure-container touch /test-file 2>&1 || echo "Filesystem is read-only (good!)"

# Cleanup
docker stop secure-container
docker rm secure-container
Task 8: Final Comparison and Analysis
Subtask 8.1: Comprehensive Image Analysis
# Create final comparison script
cat > final_analysis.sh << 'EOF'
#!/bin/bash

echo "=== Final Docker Image Analysis ==="
echo

echo "Image Sizes:"
docker images --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}" | grep -E "(simple-node-app|typescript-app|flask-app|secure-app)"
echo

echo "Layer Counts:"
for image in $(docker images --format "{{.Repository}}:{{.Tag}}" | grep -E "(simple-node-app|typescript-app|flask-app|secure-app)"); do
    layers=$(docker history $image --quiet | wc -l)
    echo "$image: $layers layers"
done
echo

echo "Security Analysis:"
for image in $(docker images --format "{{.Repository}}:{{.Tag}}" | grep -E "secure-app"); do
    echo "Checking $image..."
    docker run --rm $image id
done
EOF

chmod +x final_analysis.sh
./final_analysis.sh
Subtask 8.2: Clean Up Lab Environment
# Stop all running containers
docker stop $(docker ps -q) 2>/dev/null || true

# Remove all containers
docker rm $(docker ps -aq) 2>/dev/null || true

# Remove lab images (optional - comment out if you want to keep them)
# docker rmi $(docker images -q --filter "reference=simple-node-app*")
# docker rmi $(docker images -q --filter "reference=typescript-app*")
# docker rmi $(docker images -q --filter "reference=flask-app*")
# docker rmi $(docker images -q --filter "reference=secure-app*")
# docker rmi $(docker images -q --filter "reference=cache-demo*")

# Show remaining images
echo "Remaining images:"
docker images

# Show disk usage
echo "Docker disk usage:"
docker system df
Troubleshooting Common Issues
Build Failures
Issue: Package installation fails during build

# Solution: Update package lists and use specific versions
RUN apt-get update && apt-get install -y package-name=version
Issue: Permission denied errors

# Solution: Ensure proper ownership and user context
COPY --chown=user:group source destination
USER username
Performance Issues
Issue: Slow build times

# Solution: Optimize layer caching and use .dockerignore
# Place frequently changing files last in Dockerfile
# Use multi-stage builds to reduce final image size
Issue: Large image sizes

# Solution: Use alpine base images and multi-stage builds
FROM node:18-alpine
# Clean up package caches
RUN apt-get clean && rm -rf /var/lib/apt/lists/*
Security Concerns
Issue: Running as root user

# Solution: Always create and use non-root user
RUN useradd --create-home --shell /bin/bash appuser
USER appuser
Issue: Unnecessary packages in production

# Solution: Use multi-stage builds
# Install build dependencies in build stage only
# Copy only necessary artifacts to production stage
Key Concepts Summary
Dockerfile Best Practices
Use specific base image versions for reproducibility
Minimize layers by combining RUN commands
Leverage build cache by ordering instructions properly
Use multi-stage builds to reduce final image size
Run as non-root user for security
Use .dockerignore to reduce build context
Add health checks for container monitoring
Set appropriate environment variables
Security Considerations
Always run containers as non-root users
Use read-only filesystems when possible
Drop unnecessary capabilities
Scan images