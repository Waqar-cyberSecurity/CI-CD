Lab 7: Docker Image Management
Lab Objectives
By the end of this lab, students will be able to:

Tag Docker images with meaningful names and versions
Push Docker images to Docker Hub registry
Clean up unused Docker images to optimize disk space
Analyze Docker image sizes and identify optimization opportunities
Create and use .dockerignore files to reduce image size
Implement multi-stage builds to create smaller, more efficient Docker images
Apply best practices for Docker image management and optimization
Prerequisites
Before starting this lab, students should have:

Basic understanding of Linux command line operations
Familiarity with Docker concepts (containers, images, Dockerfile)
Knowledge of basic text editing in Linux (nano, vim, or similar)
Understanding of application development concepts
Basic knowledge of package managers and dependencies
Lab Environment Setup
Note: Al Nafi provides Linux-based cloud machines for this lab. Simply click "Start Lab" to access your dedicated Linux machine. The provided machine is bare metal with no pre-installed tools, so you will install all required tools during the lab.

Task 1: Install Docker and Setup Environment
Subtask 1.1: Install Docker Engine
First, we need to install Docker on our Linux machine.

# Update package index
sudo apt update

# Install required packages
sudo apt install -y apt-transport-https ca-certificates curl gnupg lsb-release

# Add Docker's official GPG key
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

# Add Docker repository
echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# Update package index again
sudo apt update

# Install Docker Engine
sudo apt install -y docker-ce docker-ce-cli containerd.io

# Add current user to docker group
sudo usermod -aG docker $USER

# Start and enable Docker service
sudo systemctl start docker
sudo systemctl enable docker
Subtask 1.2: Verify Docker Installation
# Log out and log back in, or use newgrp to apply group changes
newgrp docker

# Verify Docker installation
docker --version
docker info
Subtask 1.3: Create Working Directory
# Create a working directory for our lab
mkdir ~/docker-lab7
cd ~/docker-lab7
Task 2: Create Sample Applications for Image Management
Subtask 2.1: Create a Simple Node.js Application
# Create application directory
mkdir nodejs-app
cd nodejs-app

# Create package.json
cat > package.json << 'EOF'
{
  "name": "docker-lab-app",
  "version": "1.0.0",
  "description": "Sample Node.js app for Docker image management lab",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "lodash": "^4.17.21"
  }
}
EOF

# Create server.js
cat > server.js << 'EOF'
const express = require('express');
const _ = require('lodash');

const app = express();
const PORT = process.env.PORT || 3000;

app.get('/', (req, res) => {
    const message = _.capitalize('hello from docker image management lab!');
    res.json({
        message: message,
        timestamp: new Date().toISOString(),
        version: '1.0.0'
    });
});

app.get('/health', (req, res) => {
    res.json({ status: 'healthy', uptime: process.uptime() });
});

app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
EOF

# Create initial Dockerfile (unoptimized)
cat > Dockerfile << 'EOF'
FROM node:18
WORKDIR /app
COPY . .
RUN npm install
EXPOSE 3000
CMD ["npm", "start"]
EOF

cd ..
Subtask 2.2: Create Additional Files to Demonstrate .dockerignore
cd nodejs-app

# Create some unnecessary files that shouldn't be in Docker image
mkdir logs temp
echo "This is a log file" > logs/app.log
echo "Temporary data" > temp/cache.tmp
echo "Development notes" > README-dev.md
echo "node_modules/" > .gitignore

# Create some test files
mkdir tests
cat > tests/app.test.js << 'EOF'
// Test file - not needed in production
const request = require('supertest');
// Test code would go here
EOF

cd ..
Task 3: Tag Images and Push to Docker Hub
Subtask 3.1: Build Initial Docker Image
cd nodejs-app

# Build the Docker image
docker build -t nodejs-lab-app .

# Check the image size
docker images nodejs-lab-app
Subtask 3.2: Create Docker Hub Account and Login
Note: You'll need to create a free Docker Hub account at https://hub.docker.com if you don't have one.

# Login to Docker Hub (replace 'yourusername' with your actual Docker Hub username)
docker login

# Enter your Docker Hub username and password when prompted
Subtask 3.3: Tag Images with Different Versions
# Tag the image with version 1.0.0
docker tag nodejs-lab-app yourusername/nodejs-lab-app:1.0.0

# Tag the image with 'latest' tag
docker tag nodejs-lab-app yourusername/nodejs-lab-app:latest

# Tag with a development tag
docker tag nodejs-lab-app yourusername/nodejs-lab-app:dev

# List all tagged images
docker images | grep nodejs-lab-app
Subtask 3.4: Push Images to Docker Hub
# Push version 1.0.0
docker push yourusername/nodejs-lab-app:1.0.0

# Push latest version
docker push yourusername/nodejs-lab-app:latest

# Push development version
docker push yourusername/nodejs-lab-app:dev

# Verify the push was successful
docker search yourusername/nodejs-lab-app
Subtask 3.5: Pull Image from Docker Hub
# Remove local image to test pulling
docker rmi yourusername/nodejs-lab-app:1.0.0

# Pull the image back from Docker Hub
docker pull yourusername/nodejs-lab-app:1.0.0

# Verify the pulled image
docker images yourusername/nodejs-lab-app
Task 4: Clean Up Unused Images with Docker Image Prune
Subtask 4.1: Create Multiple Images for Cleanup Demo
# Build several versions of our image
docker build -t nodejs-lab-app:v1 .
docker build -t nodejs-lab-app:v2 .
docker build -t nodejs-lab-app:v3 .

# Create some dangling images by building without tags
echo "# Modified Dockerfile" >> Dockerfile
docker build .

echo "# Another modification" >> Dockerfile
docker build .

# List all images including dangling ones
docker images -a
Subtask 4.2: Identify Unused and Dangling Images
# Show dangling images (untagged images)
docker images -f "dangling=true"

# Show all images with their sizes
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}"

# Check disk usage by Docker
docker system df
Subtask 4.3: Clean Up Dangling Images
# Remove dangling images only
docker image prune

# Confirm removal by checking dangling images again
docker images -f "dangling=true"
Subtask 4.4: Clean Up All Unused Images
# Remove all unused images (not just dangling ones)
docker image prune -a

# Check the space saved
docker system df
Subtask 4.5: Automated Cleanup with Filters
# Remove images older than 24 hours
docker image prune -a --filter "until=24h"

# Remove images with specific labels (if any)
docker image prune --filter "label=version=old"

# Show cleanup summary
docker system df
Task 5: Analyze Image Size and Optimize with .dockerignore
Subtask 5.1: Analyze Current Image Size
cd nodejs-app

# Check current image size and layers
docker images nodejs-lab-app

# Inspect image layers and history
docker history nodejs-lab-app

# Get detailed size information
docker inspect nodejs-lab-app | grep -i size
Subtask 5.2: Create .dockerignore File
# Create .dockerignore file to exclude unnecessary files
cat > .dockerignore << 'EOF'
# Logs
logs/
*.log

# Temporary files
temp/
*.tmp

# Development files
README-dev.md
tests/
*.test.js

# Git files
.git/
.gitignore

# Node.js specific
node_modules/
npm-debug.log*

# OS generated files
.DS_Store
Thumbs.db

# IDE files
.vscode/
.idea/
*.swp
*.swo
EOF
Subtask 5.3: Rebuild Image with .dockerignore
# Rebuild the image with .dockerignore
docker build -t nodejs-lab-app:optimized .

# Compare sizes
echo "Original image size:"
docker images nodejs-lab-app:latest

echo "Optimized image size:"
docker images nodejs-lab-app:optimized

# Check what files are actually in the image
docker run --rm nodejs-lab-app:optimized ls -la /app
Subtask 5.4: Verify .dockerignore Effectiveness
# Create a container to inspect contents
docker run -it --rm nodejs-lab-app:optimized /bin/bash

# Inside the container, check what files exist:
# ls -la /app
# ls -la /app/logs (should not exist)
# ls -la /app/temp (should not exist)
# exit
Task 6: Implement Multi-Stage Builds for Further Optimization
Subtask 6.1: Create Multi-Stage Dockerfile
# Create an optimized multi-stage Dockerfile
cat > Dockerfile.multistage << 'EOF'
# Build stage
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# Production stage
FROM node:18-alpine AS production
WORKDIR /app

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

# Copy only production dependencies
COPY --from=builder /app/node_modules ./node_modules

# Copy application code
COPY --chown=nodejs:nodejs server.js ./

# Switch to non-root user
USER nodejs

EXPOSE 3000

CMD ["node", "server.js"]
EOF
Subtask 6.2: Build Multi-Stage Image
# Build using multi-stage Dockerfile
docker build -f Dockerfile.multistage -t nodejs-lab-app:multistage .

# Compare all image sizes
echo "Image size comparison:"
docker images | grep nodejs-lab-app | sort -k7 -h
Subtask 6.3: Advanced Multi-Stage Build with Build Tools
# Create an even more optimized multi-stage build
cat > Dockerfile.advanced << 'EOF'
# Build dependencies stage
FROM node:18-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# Build stage (if we had build steps)
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
COPY server.js ./
# In a real app, you might run build commands here
# RUN npm run build

# Production stage
FROM node:18-alpine AS runner
WORKDIR /app

# Install dumb-init for proper signal handling
RUN apk add --no-cache dumb-init

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

# Copy production dependencies
COPY --from=deps /app/node_modules ./node_modules

# Copy application
COPY --chown=nodejs:nodejs server.js ./

USER nodejs

EXPOSE 3000

ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "server.js"]
EOF

# Build the advanced multi-stage image
docker build -f Dockerfile.advanced -t nodejs-lab-app:advanced .
Subtask 6.4: Test All Optimized Images
# Test the multistage image
docker run -d -p 3001:3000 --name test-multistage nodejs-lab-app:multistage

# Test the advanced image
docker run -d -p 3002:3000 --name test-advanced nodejs-lab-app:advanced

# Test both endpoints
curl http://localhost:3001
curl http://localhost:3002

# Check container resource usage
docker stats --no-stream

# Clean up test containers
docker stop test-multistage test-advanced
docker rm test-multistage test-advanced
Task 7: Image Analysis and Best Practices
Subtask 7.1: Comprehensive Image Analysis
# Create a script to analyze all our images
cat > analyze_images.sh << 'EOF'
#!/bin/bash

echo "=== Docker Image Analysis ==="
echo

echo "All nodejs-lab-app images:"
docker images | grep nodejs-lab-app | sort -k3

echo
echo "=== Size Comparison ==="
for tag in latest optimized multistage advanced; do
    if docker images nodejs-lab-app:$tag &> /dev/null; then
        size=$(docker images nodejs-lab-app:$tag --format "{{.Size}}")
        echo "nodejs-lab-app:$tag - $size"
    fi
done

echo
echo "=== Layer Analysis ==="
echo "Layers in multistage build:"
docker history nodejs-lab-app:multistage --no-trunc

echo
echo "=== Security Scan (if available) ==="
docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
    -v $HOME/Library/Caches:/root/.cache/ \
    aquasec/trivy:latest image nodejs-lab-app:advanced || echo "Trivy not available, skipping security scan"
EOF

chmod +x analyze_images.sh
./analyze_images.sh
Subtask 7.2: Create Image Optimization Checklist
# Create a best practices checklist
cat > image_optimization_checklist.md << 'EOF'
# Docker Image Optimization Checklist

## Size Optimization
- [ ] Use .dockerignore to exclude unnecessary files
- [ ] Use multi-stage builds to separate build and runtime dependencies
- [ ] Choose appropriate base images (alpine variants when possible)
- [ ] Remove package manager cache after installations
- [ ] Combine RUN commands to reduce layers

## Security Optimization
- [ ] Use non-root users
- [ ] Keep base images updated
- [ ] Scan images for vulnerabilities
- [ ] Use specific image tags, not 'latest'
- [ ] Remove unnecessary packages and tools

## Performance Optimization
- [ ] Order Dockerfile instructions by frequency of change
- [ ] Use proper signal handling (dumb-init)
- [ ] Set appropriate resource limits
- [ ] Use health checks

## Maintenance
- [ ] Tag images with meaningful versions
- [ ] Document image contents and usage
- [ ] Regular cleanup of unused images
- [ ] Monitor image sizes over time
EOF

cat image_optimization_checklist.md
Subtask 7.3: Implement Image Cleanup Automation
# Create an automated cleanup script
cat > cleanup_docker.sh << 'EOF'
#!/bin/bash

echo "=== Docker Cleanup Script ==="
echo "Current disk usage:"
docker system df

echo
echo "Cleaning up..."

# Remove dangling images
echo "Removing dangling images..."
docker image prune -f

# Remove unused containers
echo "Removing stopped containers..."
docker container prune -f

# Remove unused networks
echo "Removing unused networks..."
docker network prune -f

# Remove unused volumes
echo "Removing unused volumes..."
docker volume prune -f

echo
echo "Cleanup complete. New disk usage:"
docker system df

echo
echo "Remaining images:"
docker images
EOF

chmod +x cleanup_docker.sh
Task 8: Final Verification and Testing
Subtask 8.1: Performance Comparison
# Test startup times of different image versions
echo "=== Startup Time Comparison ==="

for tag in latest optimized multistage advanced; do
    echo "Testing nodejs-lab-app:$tag"
    start_time=$(date +%s.%N)
    
    container_id=$(docker run -d -p 3000:3000 nodejs-lab-app:$tag)
    
    # Wait for container to be ready
    sleep 2
    
    # Test if service is responding
    if curl -s http://localhost:3000 > /dev/null; then
        end_time=$(date +%s.%N)
        startup_time=$(echo "$end_time - $start_time" | bc)
        echo "Startup time: ${startup_time}s"
    else
        echo "Failed to start"
    fi
    
    # Clean up
    docker stop $container_id > /dev/null
    docker rm $container_id > /dev/null
    
    echo "---"
done
Subtask 8.2: Create Final Summary Report
# Generate final lab report
cat > lab_summary_report.txt << 'EOF'
Docker Image Management Lab - Summary Report
==========================================

Images Created:
- nodejs-lab-app:latest (original, unoptimized)
- nodejs-lab-app:optimized (with .dockerignore)
- nodejs-lab-app:multistage (multi-stage build)
- nodejs-lab-app:advanced (advanced multi-stage with security)

Optimization Techniques Applied:
1. .dockerignore file to exclude unnecessary files
2. Multi-stage builds to separate build and runtime
3. Alpine Linux base images for smaller size
4. Non-root user for security
5. Proper signal handling with dumb-init
6. Package manager cache cleanup

Docker Hub Operations:
- Tagged images with semantic versioning
- Pushed images to Docker Hub registry
- Pulled images from registry

Cleanup Operations:
- Removed dangling images
- Cleaned up unused containers, networks, and volumes
- Implemented automated cleanup scripts

Best Practices Implemented:
- Image size optimization
- Security hardening
- Performance optimization
- Maintenance automation
EOF

# Display final image comparison
echo "=== Final Image Size Comparison ==="
docker images | grep nodejs-lab-app | awk '{print $1":"$2" - "$7}' | sort

# Show final disk usage
echo
echo "=== Final Docker Disk Usage ==="
docker system df

cat lab_summary_report.txt
Troubleshooting Tips
Common Issues and Solutions
Issue: Docker daemon not running

# Solution: Start Docker service
sudo systemctl start docker
sudo systemctl status docker
Issue: Permission denied when running Docker commands

# Solution: Add user to docker group and restart session
sudo usermod -aG docker $USER
newgrp docker
Issue: Docker Hub push fails with authentication error

# Solution: Login again and check credentials
docker logout
docker login
Issue: Image build fails due to network issues

# Solution: Check network connectivity and retry
ping google.com
docker build --no-cache -t image-name .
Issue: Container fails to start

# Solution: Check logs and inspect container
docker logs container-name
docker inspect container-name
Conclusion
In this comprehensive lab, you have successfully learned and implemented essential Docker image management techniques. You accomplished the following key objectives:

Image Management Skills Developed:

Tagged Docker images with meaningful names and version numbers
Successfully pushed and pulled images from Docker Hub registry
Implemented automated cleanup procedures to manage disk space efficiently
Image Optimization Techniques Mastered:

Created and utilized .dockerignore files to exclude unnecessary files from images
Implemented multi-stage builds to dramatically reduce final image sizes
Applied security best practices including non-root users and proper signal handling
Compared different optimization approaches and measured their effectiveness
Best Practices Implemented:

Established a systematic approach to image versioning and tagging
Created automated scripts for regular maintenance and cleanup
Developed a comprehensive understanding of image layers and their impact on size
Learned to balance image size, security, and performance considerations
Real-World Applications: These skills are crucial for production Docker deployments where image size directly impacts deployment speed, storage costs, and security posture. The optimization techniques you've learned can reduce image sizes by 50-80% while improving security and maintainability.

The automated cleanup and management scripts you created will help maintain clean Docker environments in development and production settings. Understanding multi-stage builds and .dockerignore files are essential skills for any developer working with containerized applications.

You now have the knowledge and tools to create efficient, secure, and well-managed Docker images that follow industry best practices and can be confidently deployed in production environments.